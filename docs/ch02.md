컬렉션의 사용
=====
## 목차
1. [리스트를 사용한 이터레이션](#리스트를-사용한-이터레이션)
2. [리스트 변형](#리스트-변형)
3. [엘리먼트 찾기](#엘리먼트-찾기)
4. [람다 표현식의 재사용성](#람다-표현식의-재사용성)
5. [렉시컬 스코프와 클로저 사용하기](#렉시컬-스코프와-클로저-사용하기)
6. [엘리먼트 선택](#엘리먼트-선택)
7. [컬렉션을 하나의 값으로 리듀스](#컬렉션을-하나의-값으로-리듀스)
8. [엘리먼트 조인](#엘리먼트-조인)

우리는 숫자, 문자, 객체를 사용할 때 컬렉션을 자주 이용한다. 이 장에서는 람다 표현식을 사용하여 컬렉션을 다루는 방법에 대해 알아본다. 이 장을 익히고 나면 컬렉션을 이터레이션하거나, 컬렉션에서 엘리먼트를 추출하거나 그 엘리먼트들을 쉽게 연결하는 방법에 대해 알게 될 것이다.

## 리스트를 사용한 이터레이션
리스트(List)를 이용한 이터레이션은 컬렉션의 기본 오퍼레이션이지만, 수년 동안 약간의 중요한 변화가 있었다. 여기에서는 엘리먼트를 나열하는 예제를 통해 그 방법들을 살펴본다. 먼저 아래 코드[1]는 리스트에 대한 불변(Immutable)[2] 컬렉션을 생성한다.

```java
class Friends {
    static final List<String> friends = Arrays.asList("Brian", "Nate", "Neal", "Raju", "Sara", "Scott");
}
```

이제 아래 이터레이션의 여러 스타일을 나타내는 코드와 각 특징들을 살펴보자.

1. 기존의 for 루프  
	```java
	for (int i = 0; i < Friends.friends.size(); i++) {
		System.out.println(Friends.friends.get(i));
	}
	```
	* 각각의 엘리먼트를 이터레이션해서 각 엘리먼트별로 출력하는 방식
	* 이 방법은 컬렉션에서 특정 인덱스에 있는 엘리먼트를 처리하는 경우에만 유용
2. 향상된 for 루프(JDK 5.0 이상)  
	```java
	for (String name : Friends.friends) {
		System.out.println(name);
	}
	```
	* 위 형태의 이터레이션은 내부적으로 Iterator 인터페이스를 사용하고 `hasNext()`와 `next()` 메서드를 호출
	* 명확한 제어를 위해 `break`문과 `continue`문을 사용하면 이터레이션 흐름 제어 가능
	* 특정 인덱스에서 컬렉션을 수정할 의도가 없다면 *기존의 for 루프*보다는 나은 방법
		* 하지만 위 두 방법 모두 명령형 프로그래밍 스타일(외부 이터레이터 사용)로 자바 8에서는 아래의 이유로 비권장
			1. for 루프는 본질적으로 순차적인 방식이라 병렬화 어려움
			2. 기존의 for 루프는 비다형적(non-polymorphic)
				* 태스크를 수행하기 위해 컬렉션에서 메서드를 호출하는 대신 for문에 컬렉션을 넘김
			3. 이터레이션의 자세한 구현은 `Tell, don't ask` 원칙 불만족
3. 익명 클래스(Anonymous Inner Class) 형태로 `forEach()` 메서드 이용(JDK 8.0 이상)  
	```java
	Friends.friends.forEach(new Consumer<String>() {
		@Override
		public void accept(final String name) {
			System.out.println(name);
		}
	});
	```
	* for 루프의 명령형 스타일과 다르게 내부 이터레이션을 이용해 함수형 스타일로 변경
		* 내부 라이브러리의 동작[3]으로 본질적인 작업에만 초점
	* Iterable 인터페이스는 JDK 8에서 `forEach()` 메서드를 제공
		* `forEach()` 메서드는 Consumer 타입[4]의 파라미터를 받음
			* Consumer의 인스턴스는 `accept()` 메서드를 통해 얻은 자원을 소비
		* 즉, `forEach()` 메서드는 컬렉션에서 각 엘리먼트에 대해 주어진 Consumer의 `accept()` 메서드를 호출해 작업 수행
		* 참고  
			```java
			// java.util.Arrays.ArrayList
			@SafeVarargs
			@SuppressWarnings("varargs")
			public static <T> List<T> asList(T... a) {
				return new ArrayList<>(a);
			}
			
			private static class ArrayList<E> extends AbstractList<E>
				implements RandomAccess, java.io.Serializable
			{	
				// 생략
			}
			
			// java.util.AbstractList
			public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
				// 생략
			}
			
			// java.util.List
			public interface List<E> extends Collection<E> {
				// 생략
			}
			
			// java.util.Collection
			public interface Collection<E> extends Iterable<E> {
				// 생략
			}
			
			// java.lang.Iterable
			public interface Iterable<T> {
			    default void forEach(Consumer<? super T> action) {
					Objects.requireNonNull(action);
					for (T t : this) {
						action.accept(t);
					}
				}
			}
			```
	* 단점은 `forEach()` 메서드의 파라미터로 익명 내부 클래스를 사용해 코드가 좀 장황해짐
4. 람다 표현식 형태로 `forEach()` 메서드 이용  
	```java
	Friends.friends.forEach(name -> System.out.println(name));			// 1
	Friends.friends.forEach((final String name) -> System.out.println(name));	// 2
	```
	* 익명 내부 클래스를 람다 표현식으로 대체
		* 새로운 컴파일러의 지원이 있어 가능
		* 자바 컴파일러는 명시적으로 파라미터의 타입을 설정하지 않아도 추론 가능
			* 이 경우 자바 컴파일러는 변수 `name`에 저장되어 있는 내용을 보고 `name` 파라미터가 스트링 타입이라는 것을 추론(1)
			* 단, 이때 추론한 파라미터가 `final`이 아니라는 문제 있음(1)
				* 타입을 설정하지 않고 컴파일러가 추론하게 되면 람다 표현식 내에서 파라미터를 수정하지 않도록 상당히 주의해야 함
					* 컴파일러는 설정되지 않은 파라미터의 타입은 추론할 수 있지만, 람다 표현식 내부에서 파라미터들이 변경되어도 상관없는지에 대한 부분까지는 알지 못하기 때문
				* 파라미터를 final로 마크하게 되면 람다 표현식 내부에서 파라미터가 수정되는 것을 막아줌(2)
	* 코드의 양이 줄었음에도 불구하고 코드가 분명(파라미터로 익명 내부 클래스를 이용했을 때와 비교)
		1. `forEach()` 메서드는 람다 표현식 혹은 코드 블록을 인수로 받는 고차 함수
		2. 변수 `name`은 호출을 하는 동안 컬렉션의 각 엘리먼트의 `name` 값을 저장하는 역할
	* 단, 명령형 스타일과는 달리 한번 `forEach()` 메서드를 실행하면, 내부에서 이터레이션을 멈출 수 없음
		* 따라서 이러한 스타일은 컬렉션의 엘리먼트를 모두 처리해야 하는 경우와 같은 일반적 케이스에 유용
5. 메서드 레퍼런스 형태로 `forEach()` 메서드 이용  
	```java
	Friends.friends.forEach(System.out::println);
	```
	* .

이와 같이 컬렉션에서 람다 표현식을 사용하면 이터레이션을 더 컴팩트하게 만들 수 있다.

- - -
1. .
2. Immutable
3. 내부 라이브러리의 동작  
	```txt
	- p35
	내부 라이브러리는 람다 표현식의 동작에 대한 제어를 맡게 된다. 이 람다 표현식을 호출하는 순서와 상관없이 레이지(lazy)
	<역자 주: 실행 순서를 변경할 수 있다는 의미. 이에 대해서는 6장에서 자세하게 설명하기로 한다>하게 실행되도록 할 수 
	있으며 따라서 병렬화가 가능하도록 할 수 있다.
	```
4. Consumer 타입
5. .

##### [목차로 이동](#목차)

## 리스트 변형
여기에서는 람다 표현식이 어떻게 가변성(mutablility)을 제거[1]하고 컬렉션을 변경하는 경우에 코드를 얼마나 더 간결하게 만들 수 있는지에 대해 알아본다.


- - -
1. .
2. .

##### [목차로 이동](#목차)

## 엘리먼트 찾기


##### [목차로 이동](#목차)

## 람다 표현식의 재사용성


##### [목차로 이동](#목차)

## 렉시컬 스코프와 클로저 사용하기


##### [목차로 이동](#목차)

## 엘리먼트 선택


##### [목차로 이동](#목차)

## 컬렉션을 하나의 값으로 리듀스


##### [목차로 이동](#목차)

## 엘리먼트 조인


##### [목차로 이동](#목차)